{"version":3,"file":"wysi.min.js","sources":["../src/settings.js","../src/utils.js","../src/toolset.js","../src/common.js","../src/shortcuts.js","../src/commands.js","../src/listbox.js","../src/popover.js","../src/toolbar.js","../src/filter.js","../src/core.js"],"sourcesContent":["// Default settings\nexport default {\n\n  // Default selector\n  el: '[data-wysi], .wysi-field',\n\n  // Default tools in the toolbar\n  tools: [\n    'format', '|', 'bold', 'italic', '|', \n    {\n      label: 'Text alignment',\n      items: ['alignLeft', 'alignCenter', 'alignRight', 'alignJustify']\n    }, '|',\n    'ul', 'ol', '|', 'indent', 'outdent', '|', 'link', 'image'\n  ],\n\n  // Enable dark mode (toolbar only)\n  darkMode: false,\n\n  // Height of the editable region\n  height: 200,\n\n  // Grow the editable region's height to fit its content\n  autoGrow: false,\n\n  // Hide the toolbar when the editable region is out of focus\n  autoHide: false,\n\n  // Default list of allowed tags\n  // These tags are always allowed regardless of the instance options\n  allowedTags: {\n    br: {\n      attributes: [],\n      styles: [],\n      isEmpty: true\n    },\n    p: {\n      attributes: [],\n      styles: [],\n      isEmpty: false\n    }\n  },\n\n  // Custom tags to allow when filtering inserted content\n  customTags: [\n    /* Example:\n\n    {\n      tags: ['table', 'thead', 'tbody', 'tr', 'td', 'th'], // Tags to allow\n      attributes: ['id', 'class'], // These attributes will be permitted for all the tags above\n      styles: ['width'],\n      isEmpty: false\n    }\n\n    */\n  ]\n};","import document from 'document';\nimport { hasClass } from './shortcuts.js';\n\n// Used to store the current DOM selection for later use\nlet currentSelection;\n\n// For storing translated strings\nlet availableTranslations;\n\n// Polyfill for Nodelist.forEach\nif (NodeList !== undefined && NodeList.prototype && !NodeList.prototype.forEach) {\n    NodeList.prototype.forEach = Array.prototype.forEach;\n}\n\n/**\n * Shortcut for addEventListener to optimize the minified JS.\n * @param {object} context The context to which the listener is attached.\n * @param {string} type Event type.\n * @param {(string|function)} selector Event target if delegation is used, event handler if not.\n * @param {function} [fn] Event handler if delegation is used.\n */\nexport function addListener(context, type, selector, fn) {\n  // Delegate event to the target of the selector\n  if (typeof selector === 'string') {\n    context.addEventListener(type, event => {\n      const target = event.target;\n\n      if (target.matches(selector)) {\n        fn.call(target, event);\n      }\n    });\n\n  // If the selector is not a string then it's a function\n  // in which case we need a regular event listener\n  } else {\n    fn = selector;\n    context.addEventListener(type, fn);\n  }\n}\n\n/**\n * Build an html fragment from a string.\n * @param {string} html The HTML code.\n * @return {object} A document fragment.\n */\nexport function buildFragment(html) {\n  const template = createElement('template');\n\n  template.innerHTML = html.trim();\n  return template.content;\n}\n\n/**\n * Deep clone an object.\n * @param {object} obj The object to clone.\n * @return {object} The clone object.\n */\nexport function cloneObject(obj) {\n  return obj ? JSON.parse(JSON.stringify(obj)) : obj;\n}\n\n/**\n * Create an element and optionally set its attributes.\n * @param {string} tag The HTML tag of the new element.\n * @param {object} [attributes] The element's attributes.\n * @return {object} An HTML element.\n */\nexport function createElement(tag, attributes) {\n  const element = document.createElement(tag);\n\n  if (attributes) {\n    for (const attributeName in attributes) {\n      // Attribute names starting with underscore are actually properties\n      if (attributeName[0] === '_') {\n        element[attributeName.substring(1)] = attributes[attributeName];\n      } else {\n        element.setAttribute(attributeName, attributes[attributeName]);\n      }\n    }\n  }\n\n  return element;\n}\n\n/**\n * Call a function only when the DOM is ready.\n * @param {function} fn The function to call.\n * @param {array} [args] Arguments to pass to the function.\n */\nexport function DOMReady(fn, args) {\n  args = args !== undefined ? args : [];\n\n  if (document.readyState !== 'loading') {\n    fn(...args);\n  } else {\n    addListener(document, 'DOMContentLoaded', () => {\n      fn(...args);\n    });\n  }\n}\n\n/**\n * Find the the deepest child of a node.\n * @param {object} node The target node.\n * @return {object} The deepest child node of our target node.\n */\nexport function findDeepestChildNode(node) {\n  while(node.firstChild !== null) {\n    node = node.firstChild;\n  }\n\n  return node;\n}\n\n/**\n * Find WYSIWYG editor instances.\n * @param {string} selector One or more selectors pointing to textarea fields.\n */\nexport function findEditorInstances(selector) {\n  const editorInstances = [];\n\n  getTargetElements(selector).forEach(textarea => {\n    const wrapper = textarea.previousElementSibling;\n\n    if (wrapper && hasClass(wrapper, 'wysi-wrapper')) {\n      const children = wrapper.children;\n      const toolbar = children[0];\n      const editor = children[1];\n      const instanceId = getInstanceId(editor);\n\n      editorInstances.push({ textarea, wrapper, toolbar, editor, instanceId });\n    }\n  });\n\n  return editorInstances;\n}\n\n/**\n * Find the current editor instance.\n * @param {object} currentNode The possible child node of the editor instance.\n * @return {object} The instance's editable region and toolbar, and an array of nodes that lead to it.\n */\nexport function findInstance(currentNode) {\n  const nodes = [];\n  let ancestor, toolbar, editor;\n\n  // Find all HTML tags between the current node and the editable ancestor\n  while (currentNode && currentNode !== document.body) {\n    const tag = currentNode.tagName;\n\n    if (tag) {\n      if (hasClass(currentNode, 'wysi-wrapper')) {\n        // Editable ancestor found\n        ancestor = currentNode;\n        break;\n      } else {\n        nodes.push(currentNode);\n      }\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  if (ancestor) {\n    const children = ancestor.children;\n\n    toolbar = children[0];\n    editor = children[1];\n  }\n\n  return { toolbar, editor, nodes };\n}\n\n/**\n * Get the current selection.\n * @return {object} The current selection.\n */\nexport function getCurrentSelection() {\n  return currentSelection;\n}\n\n/**\n * Get the html content of a document fragment.\n * @param {string} fragment A document fragment.\n * @return {string} The html content of the fragment.\n */\nexport function getFragmentContent(fragment) {\n  const wrapper = createElement('div');\n\n  wrapper.appendChild(fragment);\n  return wrapper.innerHTML;\n}\n\n/**\n * Get an editor's instance id.\n * @param {object} editor The editor element.\n * @return {string} The instance id.\n */ \nexport function getInstanceId(editor) {\n  return editor.dataset.wid;\n}\n\n/**\n * Get a list of DOM elements based on a selector value.\n * @param {(string|object)} selector A CSS selector string, a DOM element or a list of DOM elements.\n * @return {array} A list of DOM elements.\n */ \nexport function getTargetElements(selector) {\n  // If selector is a string, get the elements that it represents\n  if (typeof selector === 'string') {\n    return Array.from(document.querySelectorAll(selector));\n  }\n\n  // If selector is a DOM element, wrap it in an array\n  if (selector instanceof Node) {\n    return [selector];\n  }\n\n  // If selector is a NodeList or an HTMLCollection, convert it to an array\n  if (selector instanceof NodeList || selector instanceof HTMLCollection) {\n    return Array.from(selector);\n  }\n\n  // If selector is an array, find any DOM elements it contains\n  if (Array.isArray(selector)) {\n    return selector.filter(el => el instanceof Node);\n  }\n\n  return [];\n}\n\n/**\n * Try to guess the textarea element's label if any.\n * @param {object} textarea The textarea element.\n * @return {string} The textarea element's label or an empty string.\n */ \nexport function getTextAreaLabel(textarea) {\n  const parent = textarea.parentNode;\n  const id = textarea.id;\n  let labelElement;\n\n  // If the textarea element is inside a label element\n  if (parent.nodeName === 'LABEL') {\n    labelElement = parent;\n\n  // Or if the textarea element has an id, and there is a label element\n  // with an attribute \"for\" that points to that id\n  } else if (id !== undefined) {\n    labelElement = document.querySelector(`label[for=\"${id}\"]`);\n  }\n\n  // If a label element is found, return the first non empty child text node\n  if (labelElement) {\n    const textNodes = [].filter.call(labelElement.childNodes, n => n.nodeType === 3);\n    const texts = textNodes.map(n => n.textContent.replace(/\\s+/g, ' ').trim());\n    const label = texts.filter(l => l !== '')[0];\n\n    if (label) {\n      return label;\n    }\n  }\n\n  return '';\n}\n\n/**\n * Get a translated string if applicable.\n * @param {string} category The category of the string.\n * @param {string} str The string to translate.\n * @return {string} The translated string, or the original string otherwise.\n */ \nexport function getTranslation(category, str) {\n  if (availableTranslations[category] && availableTranslations[category][str]) {\n    return availableTranslations[category][str];\n  }\n\n  return str;\n}\n\n/**\n * Restore a previous selection if any.\n */\nexport function restoreSelection() {\n  if (currentSelection) {\n    setSelection(currentSelection);\n    currentSelection = undefined;\n  }\n}\n\n/**\n * Set the value of the current selection.\n * @param {object} range The range to set.\n */\nexport function setCurrentSelection(range) {\n  currentSelection = range;\n}\n\n/**\n * Set the selection to a range.\n * @param {object} range The range to select.\n */\nexport function setSelection(range) {\n  const selection = document.getSelection();\n\n  selection.removeAllRanges();\n  selection.addRange(range);\n}\n\n/**\n * Store translated strings.\n * @param {object} translations The translated strings.\n */\nexport function storeTranslations(translations) {\n  availableTranslations = translations;\n}\n\n/**\n * Set the expanded state of a button.\n * @param {object} button The button.\n * @param {boolean} expanded The expanded state.\n */\nexport function toggleButton(button, expanded) {\n  button.setAttribute('aria-expanded', expanded);\n}","// Supported tools\nexport default {\n  format: {\n    tags: ['p', 'h1', 'h2', 'h3', 'h4'],\n    styles: ['text-align'],\n    label: 'Select block format',\n    paragraph: 'Paragraph',\n    heading: 'Heading'\n  },\n  quote: {\n    tags: ['blockquote'],\n    label: 'Quote'\n  },\n  bold: {\n    tags: ['strong'],\n    alias: ['b'],\n    label: 'Bold'\n  },\n  italic: {\n    tags: ['em'],\n    alias: ['i'],\n    label: 'Italic'\n  },\n  underline: {\n    tags: ['u'],\n    label: 'Underline'\n  },\n  strike: {\n    tags: ['s'],\n    alias: ['del', 'strike'],\n    label: 'Strike-through',\n    command: 'strikeThrough'\n  },\n  alignLeft: {\n    label: 'Align left',\n    command: 'justifyLeft'\n  },\n  alignCenter: {\n    label: 'Align center',\n    command: 'justifyCenter'\n  },\n  alignRight: {\n    label: 'Align right',\n    command: 'justifyRight'\n  },\n  alignJustify: {\n    label: 'Justify',\n    command: 'justifyFull'\n  },\n  ul: {\n    tags: ['ul'],\n    extraTags: ['li'],\n    styles: ['text-align'],\n    label: 'Bulleted list',\n    command: 'insertUnorderedList'\n  },\n  ol: {\n    tags: ['ol'],\n    extraTags: ['li'],\n    styles: ['text-align'],\n    label: 'Numbered list',\n    command: 'insertOrderedList'\n  },\n  indent: {\n    label: 'Increase indent'\n  },\n  outdent: {\n    label: 'Decrease indent'\n  },\n  link: {\n    tags: ['a'],\n    attributes: ['href', 'target'],\n    attributeLabels: ['URL', 'Open link in'],\n    hasForm: true,\n    formOptions: {\n      target: [\n        {\n          label: 'Current tab',\n          value: ''\n        },\n        {\n          label: 'New tab',\n          value: '_blank'\n        }\n      ]\n    },\n    label: 'Link'\n  },\n  image: {\n    tags: ['img'],\n    attributes: ['src', 'alt'],\n    attributeLabels: ['URL', 'Alternative text'],\n    extraSettings: ['size', 'position'],\n    extraSettingLabels: ['Image size', 'Image position'],\n    styles: ['width', 'display', 'margin', 'float'],\n    isEmpty: true,\n    hasForm: true,\n    formOptions: {\n      size: [\n        {\n          label: 'None',\n          value: '',\n          criterion: null \n        },\n        {\n          label: '100%',\n          value: '100%',\n          criterion: { width: '100%' }\n        },\n        {\n          label: '50%',\n          value: '50%',\n          criterion: { width: '50%' }\n        },\n        {\n          label: '25%',\n          value: '25%',\n          criterion: { width: '25%' }\n        }\n      ],\n      position: [\n        {\n          label: 'None',\n          value: '',\n          criterion: null \n        },\n        {\n          label: 'Left',\n          value: 'left',\n          criterion: { float: 'left' }\n        },\n        {\n          label: 'Center',\n          value: 'center',\n          criterion: { margin: 'auto' }\n        },\n        {\n          label: 'Right',\n          value: 'right',\n          criterion: { float: 'right' }\n        }\n      ]\n    },\n    label: 'Image'\n  },\n  hr: {\n    tags: ['hr'],\n    isEmpty: true,\n    label: 'Horizontal line',\n    command: 'insertHorizontalRule'\n  },\n  removeFormat: {\n    label: 'Remove format'\n  },\n  unlink: {\n    label: 'Remove link'\n  }\n};","// Instances storage\nexport const instances = {};\n\n// The CSS class to use for selected elements\nexport const selectedClass = 'wysi-selected';\n\n// Placeholder elements CSS class\nexport const placeholderClass = 'wysi-fragment-placeholder';\n\n// Heading elements\nexport const headingElements = ['H1', 'H2', 'H3', 'H4'];\n\n// Block type HTML elements\nexport const blockElements = ['BLOCKQUOTE', 'HR', 'P', 'OL', 'UL'].concat(headingElements);\n\n// Detect Firefox browser\nexport const isFirefox = navigator.userAgent.search(/Gecko\\//) > -1;","import document from 'document';\n\n// Shortcuts\nexport const dispatchEvent = (element, event) => element.dispatchEvent(new Event(event, { bubbles: true }));\nexport const execCommand = (command, value = null) => document.execCommand(command, false, value);\nexport const hasClass = (element, classes) => element.classList && element.classList.contains(classes);","import toolset from './toolset.js';\nimport { restoreSelection } from './utils.js';\nimport { execCommand } from './shortcuts.js';\n\n/**\n * Execute an action.\n * @param {string} action The action to execute.\n * @param {object} editor The editor instance.\n * @param {array} [options] Optional action parameters.\n */\nexport function execAction(action, editor, options = []) {\n  const tool = toolset[action];\n  \n  if (tool) {\n    const command = tool.command || action;\n\n    // Restore selection if any\n    restoreSelection();\n\n    // Execute the tool's action\n    execEditorCommand(command, options);\n\n    // Focus the editor instance\n    editor.focus();\n  }\n}\n\n/**\n * Execute an editor command.\n * @param {string} command The command to execute.\n * @param {array} [options] Optional command parameters.\n */\nexport function execEditorCommand(command, options) {\n  switch (command) {\n    // Block level formatting\n    case 'quote':\n      options[0] = 'blockquote';\n    case 'format':\n      execCommand('formatBlock', `<${options[0]}>`);\n      break;\n\n    // Links\n    case 'link':\n      const [linkUrl, linkTarget = '', linkText] = options;\n\n      if (linkText) {\n        const targetAttr = linkTarget !== '' ? ` target=\"${linkTarget}\"` : '';\n        const linkTag = `<a href=\"${linkUrl}\"${targetAttr}>${linkText}</a>`;\n\n        execCommand('insertHTML', linkTag);\n      }\n      break;\n\n    // Images\n    case 'image':\n      const styles = [];\n      const [imageUrl, altText = '', size, position, originalHtml] = options;\n\n      if (size !== '') {\n        styles.push(`width: ${size};`);\n      }\n\n      if (position !== '') {\n        if (position === 'center') {\n          styles.push('display: block; margin: auto;')\n        } else {\n          styles.push(`float: ${position};`);\n        }\n      }\n\n      const styleAttr = styles.length > 0 ? ` style=\"${styles.join(' ')}\"` : '';\n      const image = `<img src=\"${imageUrl}\" alt=\"${altText}\" class=\"wysi-selected\"${styleAttr}>`;\n      const imageTag = originalHtml ? originalHtml.replace(/<img[^>]+>/i, image) : image;\n\n      execCommand('insertHTML', imageTag);\n      break;\n\n    // All the other commands\n    default:\n      execCommand(command);\n  }\n}","import document from 'document';\nimport toolset from './toolset.js';\nimport { instances } from './common.js';\nimport { execAction } from './commands.js';\nimport {\n  addListener,\n  createElement,\n  findInstance,\n  toggleButton\n} from './utils.js';\n\n\n/**\n * Render a list box.\n * @param {object} details The list box properties and data.\n * @return {object} A DOM element containing the list box.\n */\nfunction renderListBox(details) {\n  const label = details.label;\n  const items = details.items;\n  const firstItem = items[0];\n  const classes = ['wysi-listbox'].concat(details.classes || []);\n\n  // List box wrapper\n  const listBox = createElement('div', { class: classes.join(' ') });\n\n  // List box button\n  const button = createElement('button', {\n    type: 'button',\n    title: label,\n    'aria-label': `${label} ${firstItem.label}`,\n    'aria-haspopup': 'listbox',\n    'aria-expanded': false,\n    _innerHTML: renderListBoxItem(firstItem)\n  });\n\n  // List box menu\n  const menu = createElement('div', {\n    role: 'listbox',\n    tabindex: -1,\n    'aria-label': label\n  });\n\n  // List box items\n  items.forEach(item => {\n    const option = createElement('button', {\n      type: 'button',\n      role: 'option',\n      tabindex: -1,\n      'aria-label': item.label,\n      'aria-selected': false,\n      'data-action': item.action,\n      'data-option': item.name || '',\n      _innerHTML: renderListBoxItem(item)\n    });\n\n    menu.appendChild(option);\n  });\n\n  // Tie it all together\n  listBox.appendChild(button);\n  listBox.appendChild(menu);\n\n  return listBox;\n}\n\n/**\n * Render a list box item.\n * @param {object} item The list box item.\n * @return {string} The list box item's content.\n */\nfunction renderListBoxItem(item) {\n  return item.icon ? `<svg><use href=\"#wysi-${item.icon}\"></use></svg>` : item.label;\n}\n\n/**\n * Open a list box.\n * @param {object} button The list box's button.\n */\nfunction openListBox(button) {\n  const isOpen = button.getAttribute('aria-expanded') === 'true';\n  const listBox = button.nextElementSibling;\n  let selectedItem = listBox.querySelector('[aria-selected=\"true\"]');\n\n  if (!selectedItem) {\n    selectedItem = listBox.firstElementChild;\n  }\n\n  toggleButton(button, !isOpen);\n  selectedItem.focus();\n}\n\n/**\n * Select a list box item.\n * @param {object} item The list box item.\n */\nfunction selectListBoxItem(item) {\n  const listBox = item.parentNode;\n  const button = listBox.previousElementSibling;\n  const selectedItem = listBox.querySelector('[aria-selected=\"true\"]');\n\n  if (selectedItem) {\n    selectedItem.setAttribute('aria-selected', 'false');\n  }\n\n  item.setAttribute('aria-selected', 'true');\n  button.innerHTML = item.innerHTML;\n}\n\n/**\n * Close the currently open list box if any.\n */\nfunction closeListBox() {\n  const activeListBox = document.querySelector('.wysi-listbox [aria-expanded=\"true\"]');\n\n  if (activeListBox) {\n    toggleButton(activeListBox, false);\n  }\n}\n\n// list box button click\naddListener(document, 'click', '.wysi-listbox > button', event => {\n  closeListBox();\n  openListBox(event.target);\n});\n\n// On key press on the list box button\naddListener(document, 'keydown', '.wysi-listbox > button', event => {\n  switch (event.key) {\n    case 'ArrowUp':\n    case 'ArrowDown':\n    case 'Enter':\n    case ' ':\n      openListBox(event.target);\n      event.preventDefault();\n      break;\n  }\n});\n\n// When the mouse moves on a list box item, focus it\naddListener(document.documentElement, 'mousemove', '.wysi-listbox > div > button', event => {\n  event.target.focus();\n});\n\n// On click on an list box item\naddListener(document, 'click', '.wysi-listbox > div > button', event => {\n  const item = event.target;\n  const action = item.dataset.action;\n  const option = item.dataset.option;\n  const { editor } = findInstance(item);\n  const selection = document.getSelection();\n\n  if (selection && editor.contains(selection.anchorNode)) {\n    execAction(action, editor, [option]);\n  }\n\n  selectListBoxItem(item);\n});\n\n// On key press on an item\naddListener(document, 'keydown', '.wysi-listbox > div > button', event => {\n  const item = event.target;\n  const listBox = item.parentNode;\n  const button = listBox.previousElementSibling;\n  let preventDefault = true;\n\n  switch (event.key) {\n    case 'ArrowUp':\n      const prev = item.previousElementSibling;\n\n      if (prev) {\n        prev.focus();\n      }\n\n      break;\n    case 'ArrowDown':\n      const next = item.nextElementSibling;\n\n      if (next) {\n        next.focus();\n      }\n\n      break;\n    case 'Home':\n      listBox.firstElementChild.focus();\n      break;\n    case 'End':\n      listBox.lastElementChild.focus();\n      break;\n    case 'Tab':\n      item.click();\n      break;\n    case 'Escape':\n      toggleButton(button, false);\n      break;\n    default:\n      preventDefault = false;\n  }\n\n  if (preventDefault) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n  }\n});\n\nlet isOpeningInProgress = false;\n\n// Close open popups and dropdowns on click outside\naddListener(document, 'click', event => {\n  if (!isOpeningInProgress) {\n    closeListBox();\n  }\n});\n\n// This prevents closing a listbox immediately after opening it\naddListener(document, 'mousedown', '.wysi-listbox > button', event => isOpeningInProgress = true);\naddListener(document, 'mouseup', event => setTimeout(() => { isOpeningInProgress = false; }));\n\nexport { renderListBox, selectListBoxItem };","import document from 'document';\nimport toolset from './toolset.js';\nimport { renderListBox, selectListBoxItem } from './listbox.js';\nimport { selectedClass } from './common.js';\nimport { execAction } from './commands.js';\nimport {\n  addListener,\n  createElement,\n  findInstance,\n  getCurrentSelection,\n  getFragmentContent,\n  getTranslation,\n  restoreSelection,\n  setCurrentSelection,\n  toggleButton\n} from './utils.js';\n\n// Used to give form fields unique ids\nlet uniqueFieldId = 0;\n\n/**\n * Render a popover form to set a tool's parameters.\n * @param {string} toolName The tool name.\n * @param {object} button The tool's toolbar button.\n * @return {object} A DOM element containing the button and the popover.\n */\nfunction renderPopover(toolName, button) {\n  const tool = toolset[toolName];\n  const labels = tool.attributeLabels;\n  const fields = tool.attributes.map((attribute, i) => {\n    return {\n      name: attribute,\n      label: getTranslation(toolName, labels[i]),\n    }\n  });\n\n  // Popover wrapper\n  const wrapper = createElement('div', {\n    class: 'wysi-popover'\n  });\n\n  // Popover\n  const popover = createElement('div', {\n    tabindex: -1,\n  });\n\n  // Toolbar Button\n  button.setAttribute('aria-haspopup', true);\n  button.setAttribute('aria-expanded', false);\n\n  wrapper.appendChild(button);\n  wrapper.appendChild(popover);\n\n  fields.forEach(field => {\n    // Link target requires special handling later\n    if (toolName !== 'link' || field.name !== 'target') {\n      const label = createElement('label');\n      const span = createElement('span', { _textContent: field.label });\n      const input = createElement('input', {\n        type: 'text',\n        name: `wysi-${field.name}`,\n        'data-attribute': field.name\n      });\n\n      label.appendChild(span);\n      label.appendChild(input);\n      popover.appendChild(label);\n    }\n  });\n\n  // Link popover\n  if (toolName === 'link') {\n    // Add the target attribute\n    const targetField = fields.find(f => f.name === 'target');\n\n    if (targetField) {\n      targetField.toolName = toolName;\n      targetField.options = tool.formOptions ? tool.formOptions.target || [] : [];\n      popover.appendChild(createElement('span', { _textContent: targetField.label }));\n      popover.appendChild(renderSegmentedField(targetField));\n    }\n\n    // The link popover needs an extra \"Remove link\" button\n    const extraTool = 'unlink';\n    const label = getTranslation(toolName, toolset[extraTool].label);\n\n    popover.appendChild(createElement('button', {\n      type: 'button',\n      title: label,\n      'aria-label': label,\n      'data-action': extraTool,\n      _innerHTML: `<svg><use href=\"#wysi-delete\"></use></svg>`\n    }));\n  }\n\n  // Image popover\n  if (toolName === 'image') {\n    const imageSettings = tool.extraSettings.map((setting, i) => {\n      return {\n        name: setting,\n        label: getTranslation(toolName, tool.extraSettingLabels[i])\n      }\n    });\n\n    imageSettings.forEach(setting => {\n      setting.toolName = toolName;\n      setting.options = tool.formOptions ? tool.formOptions[setting.name] || [] : [];\n      popover.appendChild(createElement('span', { _textContent: setting.label }));\n      popover.appendChild(renderSegmentedField(setting));\n    });\n  }\n\n  const cancel = createElement('button', {\n    type: 'button',\n    _textContent: getTranslation('popover', 'Cancel')\n  });\n\n  const save = createElement('button', {\n    type: 'button',\n    'data-action': toolName,\n    _textContent: getTranslation('popover', 'Save')\n  });\n\n  popover.appendChild(cancel);\n  popover.appendChild(save);\n\n  return wrapper;\n}\n\n/**\n * Render a segmented form field.\n * @param {object} field The field attributes.\n * @return {object} A DOM element representing the segmented field.\n */\nfunction renderSegmentedField(field) {\n  const fieldId = uniqueFieldId++;\n  const segmented = createElement('fieldset', {\n    class: 'wysi-segmented'\n  });\n\n  // Add the fieldset legend for accessibility\n  segmented.appendChild(createElement('legend', { _textContent: field.label }));\n\n  // Add field options\n  field.options.forEach(option => {\n    const segmentId = uniqueFieldId++;\n\n    segmented.appendChild(createElement('input', {\n      id: `wysi-seg-${segmentId}`,\n      name: `wysi-${field.toolName}-${field.name}-${fieldId}`,\n      type: 'radio',\n      'data-attribute': field.name,\n      value: option.value\n    }));\n    \n    segmented.appendChild(createElement('label', {\n      for: `wysi-seg-${segmentId}`,\n      _textContent: getTranslation(field.toolName, option.label)\n    }));\n  });\n\n  return segmented;\n}\n\n/**\n * Open a popover.\n * @param {object} button The popover's button.\n */\nfunction openPopover(button) {\n  const inputs = button.nextElementSibling.querySelectorAll('input[type=\"text\"]');\n  const radioButtons = button.nextElementSibling.querySelectorAll('input[type=\"radio\"]');\n  const selection = document.getSelection();\n  const anchorNode = selection.anchorNode;\n  const { editor, nodes } = findInstance(anchorNode);\n  const values = {};\n\n  if (editor) {\n    // Try to find an existing target of the popover's action from the DOM selection\n    const action = button.dataset.action;\n    const tool = toolset[action];\n    let target = editor.querySelector(`.${selectedClass}`);\n    let selectContents = false;\n\n    // If that fails, look for an element with the selection CSS class\n    if (!target) {\n      target = nodes.filter(node => tool.tags.includes(node.tagName.toLowerCase()))[0];\n      selectContents = true;\n    }\n\n    // If an existing target is found, we will be in modification mode\n    if (target) {\n      const range = document.createRange();\n      \n      // Add the target to a selection range\n      // Depending on the type of the target, select the whole node or just its contents\n      if (selectContents) {\n        range.selectNodeContents(target);\n      } else {\n        range.selectNode(target);\n      }\n\n      // Save the current selection for later use\n      setCurrentSelection(range);\n\n      // Retrieve the current attribute values of the target for modification\n      tool.attributes.forEach(attribute => {\n        values[attribute] = target.getAttribute(attribute);\n      });\n\n      // Process extra popover settings\n      if (tool.extraSettings) {\n        tool.extraSettings.forEach(setting => {\n          const settingOptions = tool.formOptions[setting];\n\n          for (const option of settingOptions) {\n            if (!option.criterion) {\n              continue;\n            }\n\n            const key = Object.keys(option.criterion)[0];\n            const value = option.criterion[key];\n\n            if (target.style[key] && target.style[key] === value) {\n              values[setting] = option.value;\n              break;\n            }\n          }\n        });\n      }\n\n    // If no existing target is found, we are adding new content\n    } else if (selection && editor.contains(anchorNode) && selection.rangeCount) {\n      // Save the current selection to keep track of where to insert the content\n      setCurrentSelection(selection.getRangeAt(0));\n    }\n  }\n\n  // Populate the input fields with the existing values if any\n  inputs.forEach(input => {\n    input.value = values[input.dataset.attribute] || '';\n  });\n\n  // Check the relevent radio fields if any\n  radioButtons.forEach(radio => {\n    const value = values[radio.dataset.attribute] || '';\n\n    if (radio.value === value) {\n      radio.checked = true;\n    }\n  });\n\n  // Open this popover\n  toggleButton(button, true);\n\n  // Focus the first input field\n  inputs[0].focus();\n}\n\n/**\n * Execute a popover's action.\n * @param {object} button The popover's action button.\n */\nfunction execPopoverAction(button) {\n  const action = button.dataset.action;\n  const selection = getCurrentSelection();\n  const inputs = button.parentNode.querySelectorAll('input[type=\"text\"]');\n  const radioButtons = button.parentNode.querySelectorAll('input[type=\"radio\"]');\n  const { editor } = findInstance(button);\n  const options = [];\n\n  inputs.forEach(input => {\n    options.push(input.value);\n  });\n\n  radioButtons.forEach(radio => {\n    if (radio.checked) {\n      options.push(radio.value);\n    }\n  });\n\n  // Workaround for links being removed when updating images\n  if (action === 'image') {\n    const selected = editor.querySelector(`.${selectedClass}`);\n    const parent = selected ? selected.parentNode : {};\n\n    if (selected && parent.tagName === 'A') {\n      options.push(parent.outerHTML);\n    }\n\n  // Save the content of the current selection to use as a link text\n  } else if (action === 'link' && selection) {\n    options.push(getFragmentContent(selection.cloneContents()));\n  }\n\n  execAction(action, editor, options);\n}\n\n/**\n * Close the open popover if any.\n * @param {boolean} ignoreSelection If true, do not restore the previous selection.\n */\nfunction closePopover(ignoreSelection) {\n  const popover = document.querySelector('.wysi-popover [aria-expanded=\"true\"]');\n\n  if (popover) {\n    toggleButton(popover, false);\n  }\n\n  if (!ignoreSelection) {\n    restoreSelection();\n  }\n}\n\n// Open a popover\naddListener(document, 'click', '.wysi-popover > button', event => {\n  closePopover();\n  openPopover(event.target);\n});\n\n// On key press on the popover button\naddListener(document, 'keydown', '.wysi-popover > button', event => {\n  switch (event.key) {\n    case 'ArrowUp':\n    case 'ArrowDown':\n    case 'Enter':\n    case ' ':\n      openPopover(event.target);\n      event.preventDefault();\n      break;\n  }\n});\n\n// Execute the popover action\naddListener(document, 'click', '.wysi-popover > div > button[data-action]', event => {\n  execPopoverAction(event.target);\n  closePopover(true);\n});\n\n// Cancel the popover\naddListener(document, 'click', '.wysi-popover > div > button:not([data-action])', event => {\n  closePopover();\n});\n\n// Prevent clicks on the popover content to propagate (keep popover open)\naddListener(document, 'click', '.wysi-popover *:not(button)', event => {\n  event.stopImmediatePropagation();\n});\n\n// Trap focus inside a popover until it's closed\naddListener(document, 'keydown', '.wysi-popover *', event => {\n  const target = event.target;\n  const parent = target.parentNode;\n  const form = parent.tagName === 'DIV' ? parent : parent.parentNode;\n\n  switch (event.key) {\n    case 'Tab':\n      const firstField = form.querySelector('input');\n\n      if (event.shiftKey) {\n        if (target === firstField) {\n          form.lastElementChild.focus();\n          event.preventDefault();\n        }\n      } else {\n        if (!target.nextElementSibling && !target.parentNode.nextElementSibling) {\n          firstField.focus();\n          event.preventDefault();\n        }\n      }\n      break;\n    case 'Enter':\n      if (target.tagName === 'INPUT') {\n        const actionButton = form.querySelector('[data-action]:last-of-type');\n\n        actionButton.click();\n        event.preventDefault();\n      }\n      break;\n    case 'Escape':\n      closePopover();\n      event.stopImmediatePropagation();\n      break;\n  }\n\n});\n\nlet isSelectionInProgress = false;\n\n// Close open popups and dropdowns on click outside\naddListener(document, 'click', event => {\n  if (!isSelectionInProgress) {\n    closePopover();\n  }\n});\n\n// Text selection within a popover is in progress\n// This helps avoid closing a popover when the end of a text selection is outside it\naddListener(document, 'mousedown', '.wysi-popover, .wysi-popover *', event => {\n  isSelectionInProgress = true;\n});\n\n// The text selection ended\naddListener(document, 'mouseup', event => {\n  setTimeout(() => { isSelectionInProgress = false; });\n});\n\nexport { renderPopover };","import document from 'document';\nimport toolset from './toolset.js';\nimport { renderPopover } from './popover.js';\nimport { renderListBox, selectListBoxItem } from './listbox.js';\nimport { instances, selectedClass } from './common.js';\nimport { execAction } from './commands.js';\nimport {\n  addListener,\n  buildFragment,\n  createElement,\n  DOMReady,\n  findDeepestChildNode,\n  findInstance,\n  getInstanceId,\n  getTranslation,\n  setSelection\n} from './utils.js';\n\n/**\n * Render the toolbar.\n * @param {array} tools The list of tools in the toolbar.\n * @return {string} The toolbars HTML string.\n */\nfunction renderToolbar(tools) {\n  const toolbar = createElement('div', { class: 'wysi-toolbar' });\n\n  // Generate toolbar buttons\n  tools.forEach(toolName => {\n    switch (toolName) {\n      // Toolbar separator\n      case '|':\n        toolbar.appendChild(createElement('div', { class: 'wysi-separator' }));\n        break;\n\n      // Toolbar new line\n      case '-':\n        toolbar.appendChild(createElement('div', { class: 'wysi-newline' }));\n        break;\n\n      // The format tool renders as a list box\n      case 'format':\n        toolbar.appendChild(renderFormatTool());\n        break;\n\n      // All the other tools render as buttons\n      default:\n        if (typeof toolName === 'object') {\n          if (toolName.items) {\n            toolbar.appendChild(renderToolGroup(toolName));\n          }\n        } else {\n          renderTool(toolName, toolbar);\n        }\n    }\n  });\n\n  return toolbar;\n}\n\n/**\n * Render a tool.\n * @param {string} name The tool's name.\n * @param {object} toolbar The toolbar to which the tool will be appended.\n */\nfunction renderTool(name, toolbar) {\n  const tool = toolset[name];\n  const label = getTranslation(name, tool.label);\n  const button = createElement('button', {\n    type: 'button',\n    title: label,\n    'aria-label': label,\n    'aria-pressed': false,\n    'data-action': name,\n    _innerHTML: `<svg><use href=\"#wysi-${name}\"></use></svg>`\n  });\n\n  // Tools that require parameters (e.g: image, link) need a popover\n  if (tool.hasForm) {\n    const popover = renderPopover(name, button);\n    toolbar.appendChild(popover);\n\n  // The other tools only display a button\n  } else {\n    toolbar.appendChild(button);\n  }\n}\n\n/**\n * Render a tool group.\n * @param {object} details The group's properties.\n * @return {object} A DOM element containing the tool group.\n */\nfunction renderToolGroup(details) {\n  const label = details.label || getTranslation('toolbar', 'Select an item');\n  const options = details.items;\n\n  const items = options.map(option => {\n    const tool = toolset[option];\n    const label = getTranslation(option, tool.label);\n    const icon = option;\n    const action = option;\n\n    return { label, icon, action };\n  });\n\n  return renderListBox({ label, items });\n}\n\n/**\n * Render format tool.\n * @return {object} A DOM element containing the format tool.\n */\nfunction renderFormatTool() {\n  const toolName = 'format';\n  const label = getTranslation(toolName, toolset.format.label);\n  const paragraphLabel = getTranslation(toolName, toolset.format.paragraph);\n  const headingLabel = getTranslation(toolName, toolset.format.heading);\n  const classes = 'wysi-format';\n  const items = toolset.format.tags.map(tag => { \n    const name = tag;\n    const label = tag === 'p' ? paragraphLabel : `${headingLabel} ${tag.substring(1)}`;\n    const action = 'format';\n\n    return { name, label, action };\n  });\n\n  return renderListBox({ label, items, classes });\n}\n\n/**\n * Update toolbar buttons state.\n */\nfunction updateToolbarState() {\n  const selection = document.getSelection();\n  const anchorNode = selection.anchorNode;\n\n  if (!anchorNode) {\n    return;\n  }\n\n  const range = selection.getRangeAt(0);\n\n  // This is to fix double click selection on Firefox not highlighting the relevant tool in some cases\n  // We want to find the deepest child node to properly handle nested styles\n  const candidateNode = findDeepestChildNode(range.startContainer.nextElementSibling || range.startContainer);\n\n  // Fallback to the original selection.anchorNode if a more suitable node is not found\n  const selectedNode = range.intersectsNode(candidateNode) ? candidateNode : anchorNode;\n\n  // Get editor instance\n  const { toolbar, editor, nodes } = findInstance(selectedNode);\n  const tags = nodes.map(node => node.tagName.toLowerCase());\n\n  // Abort if the selection is not within an editor instance\n  if (!editor) {\n    return;\n  }\n\n  // Check for an element with the selection class (likely an image)\n  const selectedObject = editor.querySelector(`.${selectedClass}`);\n\n  // If such element exists, add its tag to the list of active tags\n  if (selectedObject) {\n    tags.push(selectedObject.tagName.toLowerCase());\n  }\n\n  // Get the list of allowed tags in the current editor instance\n  const instanceId = getInstanceId(editor);\n  const allowedTags = instances[instanceId].allowedTags;\n\n  // Reset the state of all buttons\n  toolbar.querySelectorAll('[aria-pressed=\"true\"]').forEach(button => button.setAttribute('aria-pressed', 'false'));\n\n  // Reset the state of all list boxes\n  toolbar.querySelectorAll('.wysi-listbox > div > button:first-of-type').forEach(button => selectListBoxItem(button));\n\n  // Update the buttons states\n  tags.forEach((tag, i) => {\n    switch (tag) {\n      case 'p':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'li':\n        const format = toolbar.querySelector(`[data-action=\"format\"][data-option=\"${tag}\"]`);\n        const textAlign = nodes[i].style.textAlign || nodes[i].getAttribute('align');\n\n        if (format) {\n          selectListBoxItem(format);\n        }\n\n        // Check for text align\n        if (textAlign) {\n          const action = 'align' + textAlign.charAt(0).toUpperCase() + textAlign.slice(1);\n          const button = toolbar.querySelector(`[data-action=\"${action}\"]`);\n          \n          if (button) {\n            if (button.parentNode.getAttribute('role') === 'listbox') {\n              selectListBoxItem(button);\n            } else {\n              button.setAttribute('aria-pressed', 'true');\n            }\n          }\n        }\n        break;\n      default:\n        const allowedTag = allowedTags[tag];\n        const action = allowedTag ? allowedTag.toolName : undefined;\n\n        if (action) {\n          const button = toolbar.querySelector(`[data-action=\"${action}\"]`);\n          button.setAttribute('aria-pressed', 'true');\n        }\n    }    \n  });\n}\n\n/**\n * Embed SVG icons in the HTML document.\n */\nfunction embedSVGIcons() {\n  // The icons will be included during the build process\n  const icons = '_SVGIcons_';\n  const svgElement = buildFragment(icons);\n\n  document.body.appendChild(svgElement);\n}\n\n// Deselect selected element when clicking outside\naddListener(document, 'mousedown', '.wysi-editor, .wysi-editor *', event => {\n  const selected = document.querySelector(`.${selectedClass}`);\n\n  if (selected && selected !== event.target) {\n    selected.classList.remove(selectedClass);\n  }\n});\n\n// Select an image when it's clicked\naddListener(document, 'mousedown', '.wysi-editor img', event => {\n  const image = event.target;\n  const range = document.createRange();\n\n  image.classList.add(selectedClass);\n\n  range.selectNode(image);\n  setSelection(range);\n});\n\n// Toolbar button click\naddListener(document, 'click', '.wysi-toolbar > button', event => {\n  const button = event.target;\n  const action = button.dataset.action;\n  const { editor } = findInstance(button);\n  const selection = document.getSelection();\n\n  if (selection && editor.contains(selection.anchorNode)) {\n    execAction(action, editor);\n  }\n});\n\n// Update the toolbar buttons state\naddListener(document, 'selectionchange', updateToolbarState);\naddListener(document, 'input', '.wysi-editor', updateToolbarState);\n\n// include SVG icons\nDOMReady(embedSVGIcons);\n\nexport { renderToolbar };","import settings from './settings.js';\nimport toolset from './toolset.js';\nimport { buildFragment, cloneObject, createElement } from './utils.js';\nimport { blockElements } from './common.js';\n\nconst STYLE_ATTRIBUTE = 'style';\nconst ALIGN_ATTRIBUTE = 'align';\n\n/**\n * Enable HTML tags belonging to a set of tools.\n * @param {array} tools A array of tool objects.\n * @return {object} The list of allowed tags.\n */\nfunction enableTags(tools) {\n  const allowedTags = cloneObject(settings.allowedTags);\n\n  tools.forEach(toolName => {\n    const tool = cloneObject(toolset[toolName]);\n\n    if (!tool || !tool.tags) {\n      return;\n    }\n\n    const isEmpty = !!tool.isEmpty;\n    const extraTags = tool.extraTags || [];\n    const aliasList = tool.alias || [];\n    const alias = aliasList.length ? tool.tags[0] : undefined;\n    const tags = [...tool.tags, ...extraTags, ...aliasList];\n    const attributes = tool.attributes || [];\n    const styles = tool.styles || [];\n\n    tags.forEach(tag => {\n      allowedTags[tag] = { attributes, styles, alias, isEmpty };\n      \n      if (!extraTags.includes(tag)) {\n        allowedTags[tag].toolName = toolName;\n      }\n    });\n  });\n\n  return allowedTags;\n}\n\n/**\n * Prepare raw content for editing.\n * @param {string} content The raw content.\n * @param {array} allowedTags The list of allowed tags.\n * @param {boolean} filterOnly If true, only filter the content, without further cleaning.\n * @return {string} The filtered HTML content.\n */\nfunction prepareContent(content, allowedTags, filterOnly) {\n  const container = createElement('div');\n  const fragment = buildFragment(content);\n\n  filterContent(fragment, allowedTags);\n\n  if (!filterOnly) {\n    wrapTextNodes(fragment);\n    cleanContent(fragment, allowedTags);\n  }\n\n  container.appendChild(fragment);\n\n  return container.innerHTML;\n}\n\n/**\n * Replace a DOM element with another while preserving its content.\n * @param {object} node The element to replace.\n * @param {string} tag The HTML tag of the new element.\n * @param {boolean} [copyAttributes] If true, also copy the original element's attributes.\n */\nfunction replaceNode(node, tag, copyAttributes) {\n  const newElement = createElement(tag);\n  const parentNode = node.parentNode;\n  const attributes = node.attributes;\n\n  // Copy the original element's content\n  newElement.innerHTML = node.innerHTML || node.textContent || node.outerHTML;\n\n  // Copy the original element's attributes\n  if (copyAttributes && attributes) {\n    for (let i = 0; i < attributes.length; i++) {\n      newElement.setAttribute(attributes[i].name, attributes[i].value);\n    }\n  }\n\n  // Replace the element\n  parentNode.replaceChild(newElement, node);\n}\n\n/**\n * Remove unsupported CSS styles from a node.\n * @param {object} node The element to filter.\n * @param {array} allowedStyles An array of supported styles.\n */\nfunction filterStyles(node, allowedStyles) {\n  const styleAttribute = node.getAttribute(STYLE_ATTRIBUTE);\n\n  if (styleAttribute) {\n    // Parse the styles\n    const styles = styleAttribute.split(';').map(style => {\n      const prop = style.split(':');\n      \n      return {\n        name: prop[0].trim(),\n        value: prop[1]\n      };\n    })\n    // Filter the styles\n    .filter(style => allowedStyles.includes(style.name))\n\n    // Remove text-align: left\n    .filter(style => style.name !== 'text-align' || style.value.trim() !== 'left')\n\n    // Convert back to a style string\n    .map(({ name, value }) => `${name}: ${value.trim()};`).join('');\n\n    if (styles !== '') {\n      node.setAttribute(STYLE_ATTRIBUTE, styles);\n    } else {\n      node.removeAttribute(STYLE_ATTRIBUTE);\n    }\n  }\n}\n\n/**\n * Remove unsupported HTML tags and attributes.\n * @param {object} node The parent element to filter recursively.\n * @param {array} allowedTags The list of allowed tags.\n */\nfunction filterContent(node, allowedTags) {\n  const children = Array.from(node.childNodes);\n\n  if (!children || !children.length) {\n    return;\n  }\n\n  children.forEach(childNode => {\n    // Element nodes\n    if (childNode.nodeType === 1) {\n      // Filter recursively (deeper nodes first)\n      filterContent(childNode, allowedTags);\n\n      // Check if the current element is allowed\n      const tag = childNode.tagName.toLowerCase();\n      const allowedTag = allowedTags[tag];\n      const attributes = Array.from(childNode.attributes);\n\n      // Check for the deprecated align attribute (mainly in Firefox)\n      const deprecatedAlignAttribute = childNode.getAttribute(ALIGN_ATTRIBUTE);\n\n      if (allowedTag) {\n        const allowedAttributes = allowedTag.attributes || [];\n        const allowedStyles = allowedTag.styles || [];\n\n        // Remove attributes that are not allowed\n        for (let i = 0; i < attributes.length; i++) {\n          const attributeName = attributes[i].name;\n\n          if (!allowedAttributes.includes(attributes[i].name)) {\n            // Replace deprecated align attribute with text-align style\n            if (attributeName === ALIGN_ATTRIBUTE) {\n              if (deprecatedAlignAttribute !== 'left') {\n                childNode.style.textAlign = deprecatedAlignAttribute;\n              }\n            }\n\n            if (attributeName === STYLE_ATTRIBUTE && allowedStyles.length) {\n              filterStyles(childNode, allowedStyles);\n            } else {\n              childNode.removeAttribute(attributes[i].name);\n            }\n          }\n        }\n\n        // If the tag is an alias, replace it with the standard tag\n        // e.g: <b> tags will be replaced with <strong> tags\n        if (allowedTag.alias) {\n          replaceNode(childNode, allowedTag.alias, true);\n        }\n      } else {\n        // Remove style nodes\n        if (tag === 'style') {\n          node.removeChild(childNode);\n\n        // And unwrap the other nodes\n        } else {\n          // Fix bad alignment handling on Firefox\n          if (deprecatedAlignAttribute !== null) {\n            if (childNode.parentNode && childNode.parentNode.tagName === 'LI') {\n              childNode.parentNode.style.textAlign = deprecatedAlignAttribute;\n            } else {\n              for (const divChild of childNode.childNodes) {\n                divChild.style.textAlign = deprecatedAlignAttribute;\n              }\n            }\n          }\n\n          childNode.replaceWith(...childNode.childNodes);\n        }\n      }\n\n    // Remove comment nodes\n    } else if (childNode.nodeType === 8) {\n      node.removeChild(childNode);\n    }\n  });\n}\n\n/**\n * Remove empty nodes.\n * @param {object} node The parent element to filter recursively.\n * @param {array} allowedTags The list of allowed tags.\n */\nfunction cleanContent(node, allowedTags) {\n  const children = Array.from(node.childNodes);\n\n  if (!children || !children.length) {\n    return;\n  }\n\n  children.forEach(childNode => {\n    // Remove empty element nodes\n    if (childNode.nodeType === 1) {\n      // Filter recursively (deeper nodes first)\n      cleanContent(childNode, allowedTags);\n\n      // Check if the element can be empty\n      const tag = childNode.tagName.toLowerCase();\n      const allowedTag = allowedTags[tag];\n\n      if (allowedTag && !allowedTag.isEmpty && trimText(childNode.innerHTML) === '') {\n        node.removeChild(childNode);\n      }\n    }\n  });\n}\n\n/**\n * Wrap the child text nodes in a paragraph (non-recursively).\n * @param {object} node The parent element of the text nodes.\n */\nfunction wrapTextNodes(node) {\n  const children = Array.from(node.childNodes);\n\n  if (!children || !children.length) {\n    return;\n  }\n\n  let appendToPrev = false;\n\n  children.forEach(childNode => {\n    if (childNode.nodeType !== 3 && blockElements.includes(childNode.tagName)) {\n      appendToPrev = false;\n      return;\n    }\n\n    // Remove empty text node\n    /*if (trimText(childNode.textContent) === '') {\n      node.removeChild(childNode);\n\n    // Wrap text node in a paragraph\n    } else {*/\n      if (appendToPrev) {\n        const prev = childNode.previousElementSibling;\n\n        if (prev) {\n          prev.appendChild(childNode);\n        }\n      } else {\n        replaceNode(childNode, 'p');\n        appendToPrev = true;\n      }\n    /*}*/\n  });\n}\n\n/**\n * Trim whitespace from the start and end of a text.\n * @param {string} text The text to trim.\n * @return {string} The trimmed text.\n */\nfunction trimText(text) {\n  return text.replace(/^\\s+|\\s+$/g, '').trim();\n}\n\nexport {\n  enableTags,\n  prepareContent\n};","import window from 'window';\nimport document from 'document';\nimport settings from './settings.js';\nimport { renderToolbar } from './toolbar.js';\nimport { enableTags, prepareContent } from './filter.js';\nimport {\n  instances,\n  placeholderClass,\n  headingElements,\n  blockElements,\n  isFirefox\n} from './common.js';\nimport { \n  addListener,\n  cloneObject,\n  createElement,\n  DOMReady,\n  findEditorInstances,\n  findInstance,\n  getInstanceId,\n  getTargetElements,\n  getTextAreaLabel,\n  storeTranslations\n} from './utils.js';\nimport {\n  dispatchEvent,\n  execCommand,\n  hasClass\n} from './shortcuts.js';\n\n// Next available instance id\nlet nextId = 0;\n\n/**\n * Init WYSIWYG editor instances.\n * @param {object} options Configuration options.\n */\nfunction init(options) {\n  const globalTranslations = window.wysiGlobalTranslations || {};\n  const translations = Object.assign({}, globalTranslations, options.translations || {});\n\n  // Store translated strings\n  storeTranslations(translations);\n\n  const tools = options.tools || settings.tools;\n  const selector = options.el || settings.el;\n  const targetEls = getTargetElements(selector);\n  const toolbar = renderToolbar(tools);\n  const allowedTags = enableTags(tools);\n  const customTags = options.customTags || [];\n\n  // Add custom tags if any to the allowed tags list\n  customTags.forEach(custom => {\n    if (custom.tags) {\n      const attributes = custom.attributes || [];\n      const styles = custom.styles || [];\n      const isEmpty = !!custom.isEmpty;\n\n      custom.tags.forEach(tag => {\n        allowedTags[tag] = { attributes, styles, isEmpty };\n      });\n    }\n  });\n\n  // Append an editor instance to target elements\n  targetEls.forEach(field => {\n    const sibling = field.previousElementSibling;\n\n    if (!sibling || !hasClass(sibling, 'wysi-wrapper')) {\n      const instanceId = nextId++;\n\n      // Store the instance's options \n      instances[instanceId] = options;\n\n      // Cache the list of allowed tags in the instance\n      instances[instanceId].allowedTags = cloneObject(allowedTags);\n\n      // Wrapper\n      const wrapper = createElement('div', {\n        class: 'wysi-wrapper'\n      });\n\n      // Editable region\n      const editor = createElement('div', {\n        class: 'wysi-editor',\n        contenteditable: true,\n        role: 'textbox',\n        'aria-multiline': true,\n        'aria-label': getTextAreaLabel(field),\n        'data-wid': instanceId,\n        _innerHTML: prepareContent(field.value, allowedTags)\n      });      \n\n      // Insert the editor instance in the document\n      wrapper.appendChild(toolbar.cloneNode(true));\n      wrapper.appendChild(editor);\n      field.before(wrapper);\n\n      // Apply configuration\n      configure(wrapper, options);\n\n    // Reconfigure instance\n    } else {\n      configure(sibling, options);\n    }\n  });\n}\n\n/**\n * Configure a WYSIWYG editor instance.\n * @param {object} instance The editor instance to configure.\n * @param {object} options The configuration options.\n */\nfunction configure(instance, options) {\n  if (typeof options !== 'object') {\n    return;\n  }\n\n  for (const key in options) {\n    switch (key) {\n      case 'darkMode':\n      case 'autoGrow':\n      case 'autoHide':\n        instance.classList.toggle(`wysi-${key.toLowerCase()}`, !!options[key]);\n        break;\n      case 'height':\n        const height = options.height;\n\n        if (!isNaN(height)) {\n          const editor = instance.lastChild;\n\n          editor.style.minHeight = `${height}px`;\n          editor.style.maxHeight = `${height}px`;\n        }\n        break;\n    }\n  }\n}\n\n/**\n * Update the content of a WYSIWYG editor instance.\n * @param {object} textarea The textarea eleement.\n * @param {object} editor The editable region.\n * @param {string} instanceId The id of the instance.\n * @param {string} rawContent The new unfiltered content of the instance.\n * @param {boolean} setEditorContent Whether to update the content of the editable region.\n */\nfunction updateContent(textarea, editor, instanceId, rawContent, setEditorContent) {\n  const instance = instances[instanceId];\n  const content = prepareContent(rawContent, instance.allowedTags);\n  const onChange = instance.onChange;\n\n  if (setEditorContent === true) {\n    editor.innerHTML = content;\n  }\n\n  textarea.value = content;\n  dispatchEvent(textarea, 'change');\n\n  if (onChange) {\n    onChange(content);\n  }\n}\n\n/**\n * Destroy a WYSIWYG editor instance.\n * @param {string} selector One or more selectors pointing to textarea fields.\n */\nfunction destroy(selector) {\n  const editorInstances = findEditorInstances(selector);\n\n  for (const editorInstance of editorInstances) {\n    const { instanceId, wrapper } = editorInstance;\n\n    delete instances[instanceId];\n    wrapper.remove();\n  }\n}\n\n/**\n * Set the content of a WYSIWYG editor instance programmatically.\n * @param {string} selector One or more selectors pointing to textarea fields.\n */\nfunction setContent(selector, content) {\n  const editorInstances = findEditorInstances(selector);\n\n  for (const editorInstance of editorInstances) {\n    const { textarea, editor, instanceId } = editorInstance;\n\n    updateContent(textarea, editor, instanceId, content, true);\n  }\n}\n\n/**\n * Clean up content before pasting it in an editor.\n * @param {object} event The browser's paste event.\n */\nfunction cleanPastedContent(event) {\n  const { editor, nodes } = findInstance(event.target);\n  const clipboardData = event.clipboardData;\n\n  if (editor && clipboardData.types.includes('text/html')) {\n    const pasted = clipboardData.getData('text/html');\n    const instanceId = getInstanceId(editor);\n    const allowedTags = instances[instanceId].allowedTags;\n    let content = prepareContent(pasted, allowedTags);\n\n    // Detect a heading tag in the current selection\n    const splitHeadingTag = nodes.filter(n => headingElements.includes(n.tagName)).length > 0;\n\n    // Force split the heading tag if any.\n    // This fixes a bug in Webkit/Blink browsers where the whole content is converted to a heading\n    if (splitHeadingTag && !isFirefox) {\n      const splitter = `<h1 class=\"${placeholderClass}\"><br></h1><p class=\"${placeholderClass}\"><br></p>`;\n      content = splitter + content + splitter;\n    }\n\n    // Manually paste the cleaned content\n    execCommand('insertHTML', content);\n\n    if (splitHeadingTag && !isFirefox) {\n      // Remove placeholder elements if any\n      editor.querySelectorAll(`.${placeholderClass}`).forEach(fragment => {\n        fragment.remove();\n      });\n\n      // Unwrap nested heading elements to fix a bug in Webkit/Blink browsers\n      editor.querySelectorAll(headingElements.join()).forEach(heading => {\n        const firstChild = heading.firstElementChild;\n\n        if (firstChild && blockElements.includes(firstChild.tagName)) {\n          heading.replaceWith(...heading.childNodes);\n        }\n      });\n    }\n\n    // Prevent the default paste action\n    event.preventDefault();\n  }\n}\n\n\n/**\n * Bootstrap the WYSIWYG editor.\n */\nfunction bootstrap() {\n  // Configure editable regions\n  execCommand('styleWithCSS', false);\n  execCommand('enableObjectResizing', false);\n  execCommand('enableInlineTableEditing', false);\n  execCommand('defaultParagraphSeparator', 'p');\n\n  // Update the textarea value when the editor's content changes\n  addListener(document, 'input', '.wysi-editor', event => {\n    const editor = event.target;\n    const textarea = editor.parentNode.nextElementSibling;\n    const instanceId = getInstanceId(editor);\n    const content = editor.innerHTML;\n\n    updateContent(textarea, editor, instanceId, content);\n  });\n\n  // Clean up pasted content\n  addListener(document, 'paste', cleanPastedContent);\n}\n\n// Expose Wysi to the global scope\nwindow.Wysi = (() => {\n  const methods = {\n    destroy,\n    setContent\n  };\n\n  function Wysi(options) {\n    DOMReady(() => {\n      init(options || {});\n    });\n  }\n\n  for (const key in methods) {\n    Wysi[key] = (...args) => {\n      DOMReady(methods[key], args);\n    };\n  }\n\n  return Wysi;\n})();\n\n// Bootstrap Wysi when the DOM is ready\nDOMReady(bootstrap);\n"],"names":["currentSelection","availableTranslations","settings","el","tools","label","items","darkMode","height","autoGrow","autoHide","allowedTags","br","attributes","styles","isEmpty","p","customTags","toolset","format","tags","paragraph","heading","quote","bold","alias","italic","underline","strike","command","alignLeft","alignCenter","alignRight","alignJustify","ul","extraTags","ol","indent","outdent","link","attributeLabels","hasForm","formOptions","target","value","image","extraSettings","extraSettingLabels","size","criterion","width","position","float","margin","hr","removeFormat","unlink","instances","selectedClass","placeholderClass","headingElements","blockElements","concat","isFirefox","navigator","userAgent","search","dispatchEvent","element","event","Event","bubbles","execCommand","document","hasClass","classes","classList","contains","addListener","context","type","selector","fn","addEventListener","matches","call","buildFragment","html","template","createElement","innerHTML","trim","content","cloneObject","obj","JSON","parse","stringify","tag","attributeName","substring","setAttribute","DOMReady","args","undefined","readyState","apply","findEditorInstances","editorInstances","getTargetElements","forEach","textarea","wrapper","previousElementSibling","children","toolbar","editor","instanceId","getInstanceId","push","findInstance","currentNode","ancestor","nodes","body","tagName","parentNode","dataset","wid","Array","from","querySelectorAll","Node","NodeList","HTMLCollection","isArray","filter","getTextAreaLabel","labelElement","parent","id","nodeName","querySelector","childNodes","n","nodeType","map","textContent","replace","l","getTranslation","category","str","restoreSelection","setSelection","setCurrentSelection","range","selection","getSelection","removeAllRanges","addRange","toggleButton","button","expanded","execAction","action","options","tool","linkUrl","_options$","linkTarget","linkText","imageUrl","_options$2","altText","originalHtml","length","join","imageTag","execEditorCommand","focus","renderListBox","details","firstItem","listBox","class","title","_innerHTML","renderListBoxItem","menu","role","tabindex","item","option","name","appendChild","icon","openListBox","isOpen","getAttribute","nextElementSibling","selectedItem","firstElementChild","selectListBoxItem","closeListBox","activeListBox","prototype","key","preventDefault","documentElement","anchorNode","prev","next","lastElementChild","click","stopImmediatePropagation","isOpeningInProgress","setTimeout","uniqueFieldId","renderSegmentedField","field","fieldId","segmented","_textContent","segmentId","toolName","for","openPopover","inputs","radioButtons","_findInstance","values","selectContents","node","includes","toLowerCase","createRange","selectNodeContents","selectNode","attribute","setting","_step","_iterator","_createForOfIteratorHelperLoose","done","Object","keys","style","rangeCount","getRangeAt","input","radio","checked","execPopoverAction","fragment","selected","outerHTML","cloneContents","closePopover","ignoreSelection","popover","form","firstField","shiftKey","isSelectionInProgress","renderToolbar","paragraphLabel","headingLabel","renderFormatTool","labels","fields","i","span","targetField","find","f","extraTool","cancel","save","renderPopover","renderTool","updateToolbarState","candidateNode","firstChild","findDeepestChildNode","startContainer","intersectsNode","selectedObject","textAlign","charAt","toUpperCase","slice","allowedTag","remove","add","svgElement","STYLE_ATTRIBUTE","ALIGN_ATTRIBUTE","prepareContent","filterOnly","container","filterContent","appendToPrev","childNode","replaceNode","wrapTextNodes","cleanContent","copyAttributes","newElement","replaceChild","filterStyles","allowedStyles","styleAttribute","split","prop","_ref","removeAttribute","deprecatedAlignAttribute","allowedAttributes","removeChild","replaceWith","nextId","init","globalTranslations","window","wysiGlobalTranslations","translations","storeTranslations","assign","targetEls","aliasList","enableTags","custom","sibling","configure","contenteditable","cloneNode","before","instance","toggle","isNaN","lastChild","minHeight","maxHeight","updateContent","rawContent","setEditorContent","onChange","destroy","editorInstance","setContent","_step2","_iterator2","cleanPastedContent","clipboardData","types","pasted","getData","splitHeadingTag","splitter","Wysi","methods","_loop","_len","arguments","_key"],"mappings":"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"}